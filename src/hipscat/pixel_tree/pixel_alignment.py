from typing import List, Tuple

import numba
import numpy as np
import pandas as pd
from numba import njit

from hipscat.pixel_math import HealpixInputTypes, HealpixPixel, get_healpix_pixel
from hipscat.pixel_math.healpix_pixel_convertor import get_healpix_tuple
from hipscat.pixel_tree.pixel_alignment_types import PixelAlignmentType
from hipscat.pixel_tree.pixel_node_type import PixelNodeType
from hipscat.pixel_tree.pixel_tree import PixelTree
from hipscat.pixel_tree.pixel_tree_builder import PixelTreeBuilder

LEFT_TREE_KEY = "left"
RIGHT_TREE_KEY = "right"


# pylint: disable=R0903
class PixelAlignment:
    """Represents how two pixel trees align with each other, meaning which pixels match
    or overlap between the catalogs, and a new tree with the smallest pixels from each tree

    For more information on the pixel alignment algorithm, view this document:
    https://docs.google.com/document/d/1YFAQsGCgeEyEZ1IRIam9BbWdN5h2onV6ndO3VM-qjn0/edit?usp=sharing

    Attributes:
        pixel_mapping: A dataframe where each row contains a pixel from each tree that match, and
            which pixel in the aligned tree they match with
        pixel_tree: The aligned tree generated by using the smallest pixels in each tree. For
            example, a tree with pixels at order 0, pixel 1, and a tree with order 1, pixel 4,5,6,
            and 7, would result in the smaller order 1 pixels in the aligned tree.
        alignment_type: The type of alignment describing how to handle nodes which exist in one tree
            but not the other. Options are:

                - inner - only use pixels that appear in both catalogs
                - left - use all pixels that appear in the left catalog and any overlapping from the right
                - right - use all pixels that appear in the right catalog and any overlapping from the left
                - outer - use all pixels from both catalogs
    """

    PRIMARY_ORDER_COLUMN_NAME = "primary_Norder"
    PRIMARY_PIXEL_COLUMN_NAME = "primary_Npix"
    JOIN_ORDER_COLUMN_NAME = "join_Norder"
    JOIN_PIXEL_COLUMN_NAME = "join_Npix"
    ALIGNED_ORDER_COLUMN_NAME = "aligned_Norder"
    ALIGNED_PIXEL_COLUMN_NAME = "aligned_Npix"

    def __init__(
        self,
        aligned_tree: PixelTree,
        pixel_mapping: pd.DataFrame,
        alignment_type: PixelAlignmentType,
    ) -> None:
        self.pixel_tree = aligned_tree
        self.pixel_mapping = pixel_mapping
        self.alignment_type = alignment_type


def align_trees(
    left: PixelTree,
    right: PixelTree,
    alignment_type: PixelAlignmentType = PixelAlignmentType.INNER
) -> PixelAlignment:
    max_n = max(left.order, right.order)
    left_aligned = left.pixels << (2 * (max_n - left.order))
    right_aligned = right.pixels << (2 * (max_n - right.order))
    if alignment_type == PixelAlignmentType.INNER:
        result_tree, mapping = align_inner_trees(left_aligned, right_aligned)
        result_tree = np.array(result_tree)
        mapping = np.array(mapping).T
    else:
        raise NotImplementedError()
    result_mapping = get_pixel_mapping_df(mapping, max_n)
    return PixelAlignment(PixelTree(result_tree, max_n), result_mapping, alignment_type)


def get_pixel_mapping_df(mapping: np.ndarray, map_order: int) -> pd.DataFrame:
    l_orders = map_order - ((np.vectorize(lambda x: int(x).bit_length())(mapping[1] - mapping[0]) - 1) >> 1)
    l_pixels = mapping[0] >> (map_order - l_orders)
    r_orders = map_order - ((np.vectorize(lambda x: int(x).bit_length())(mapping[3] - mapping[2]) - 1) >> 1)
    r_pixels = mapping[2] >> (map_order - r_orders)
    a_orders = map_order - ((np.vectorize(lambda x: int(x).bit_length())(mapping[5] - mapping[4]) - 1) >> 1)
    a_pixels = mapping[4] >> (map_order - a_orders)
    result_mapping = pd.DataFrame.from_dict({
        PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: l_orders,
        PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: l_pixels,
        PixelAlignment.JOIN_ORDER_COLUMN_NAME: r_orders,
        PixelAlignment.JOIN_PIXEL_COLUMN_NAME: r_pixels,
        PixelAlignment.ALIGNED_ORDER_COLUMN_NAME: a_orders,
        PixelAlignment.ALIGNED_PIXEL_COLUMN_NAME: a_pixels,
    })
    return result_mapping


@njit(numba.types.Tuple((numba.types.List(numba.int64[:]), numba.types.List(numba.int64[::1])))(numba.int64[:, :], numba.int64[:, :]))
def align_inner_trees(
    left: np.ndarray,
    right: np.ndarray,
) -> Tuple[List[np.ndarray], List[np.ndarray]]:
    """Generate a `PixelAlignment` object from two pixel trees

    A `PixelAlignment` represents how two pixel trees align with each other, meaning which pixels
    match or overlap between the catalogs, and includes a new tree with the smallest pixels from
    each tree

    For more information on the pixel alignment algorithm, view this document:
    https://docs.google.com/document/d/1YFAQsGCgeEyEZ1IRIam9BbWdN5h2onV6ndO3VM-qjn0/edit?usp=sharing

    Args:
        left: The left tree to align
        right: The right tree to align
        alignment_type: The type of alignment describing how to handle nodes which exist in one tree
            but not the other. Options are:

                - inner - only use pixels that appear in both catalogs
                - left - use all pixels that appear in the left catalog and any overlapping from the right
                - right - use all pixels that appear in the right catalog and any overlapping from the left
                - outer - use all pixels from both catalogs

    Returns:
        The `PixelAlignment` object with the alignment from the two trees
    """

    output = []
    mapping = []
    left_index = 0
    right_index = 0
    while left_index < len(left) and right_index < len(right):
        left_pix = left[left_index]
        right_pix = right[right_index]
        if left_pix[0] >= right_pix[1]:
            # left pix ahead of right, no overlap
            right_index += 1
            continue
        if right_pix[0] >= left_pix[1]:
            # right pix ahead of left, no overlap
            left_index += 1
            continue
        left_size = left_pix[1] - left_pix[0]
        right_size = right_pix[1] - right_pix[0]
        if left_size == right_size:
            # overlapping + same size => same pixel so add and move both on
            output.append(left_pix)
            mapping.append(np.concatenate((left_pix, right_pix, left_pix)))
            left_index += 1
            right_index += 1
            continue
        if left_size < right_size:
            # overlapping and left smaller so add left and move left on
            output.append(left_pix)
            mapping.append(np.concatenate((left_pix, right_pix, left_pix)))
            left_index += 1
            continue
        output.append(right_pix)
        mapping.append(np.concatenate((left_pix, right_pix, right_pix)))
        right_index += 1
    return output, mapping


    # tree_builder = PixelTreeBuilder()
    # pixels_to_search = _get_children_pixels_from_trees([left, right], (-1, -1))
    #
    # while len(pixels_to_search) > 0:
    #     search_pixel = pixels_to_search.pop(0)
    #     if search_pixel in left and search_pixel in right:
    #         left_node_type = left.get_node_type(search_pixel)
    #         right_node_type = right.get_node_type(search_pixel)
    #         if left_node_type == right_node_type:
    #             if left_node_type == PixelNodeType.LEAF:
    #                 # Matching leaf nodes get added to the aligned tree
    #                 tree_builder.create_node_and_parent_if_not_exist(search_pixel, PixelNodeType.LEAF)
    #             else:
    #                 # For matching inner nodes search into their children to check for alignment
    #                 pixels_to_search += _get_children_pixels_from_trees([left, right], search_pixel)
    #         else:
    #             # Nodes with non-matching types: one must be a leaf and the other an inner node
    #             if left_node_type == PixelNodeType.LEAF:
    #                 tree_with_leaf_node = LEFT_TREE_KEY
    #                 inner_node = (search_pixel, right)
    #             else:
    #                 tree_with_leaf_node = RIGHT_TREE_KEY
    #                 inner_node = (search_pixel, left)
    #             if _should_include_all_pixels_from_tree(tree_with_leaf_node, alignment_type):
    #                 # If the alignment type means fully covering the tree with the leaf node, then
    #                 # create a leaf node in the aligned tree and split it to match the partitioning
    #                 # of the other tree to ensure the node is fully covered
    #                 tree_builder.create_node_and_parent_if_not_exist(search_pixel, PixelNodeType.LEAF)
    #                 tree_builder.split_leaf_to_match_partitioning(inner_node)
    #             else:
    #                 # Otherwise just add the subtree from the inner node to include all the
    #                 # overlapping pixels
    #                 tree_builder.create_node_and_parent_if_not_exist(search_pixel, PixelNodeType.INNER)
    #                 tree_builder.add_all_descendants_from_node(inner_node)
    #     elif search_pixel in left and search_pixel not in right:
    #         # For nodes that only exist in one tree, include them if the alignment type means that
    #         # tree should have all its nodes included
    #         if _should_include_all_pixels_from_tree(LEFT_TREE_KEY, alignment_type):
    #             tree_builder.create_node_and_parent_if_not_exist(search_pixel, left.get_node_type(search_pixel))
    #             tree_builder.add_all_descendants_from_node((search_pixel, left))
    #     elif search_pixel in right and search_pixel not in left:
    #         if _should_include_all_pixels_from_tree(RIGHT_TREE_KEY, alignment_type):
    #             tree_builder.create_node_and_parent_if_not_exist(search_pixel, right.get_node_type(search_pixel))
    #             tree_builder.add_all_descendants_from_node((search_pixel, right))
    # tree = tree_builder.build()
    # pixel_mapping = _generate_pixel_mapping_from_tree(left, right, tree)
    # return PixelAlignment(tree, pixel_mapping, alignment_type)


def _get_children_pixels_from_trees(trees: List[PixelTree], pixel: HealpixInputTypes) -> List[Tuple[int, int]]:
    """Returns the combined HEALPix pixels that have child nodes of the given pixel from trees

    This returns a list of HEALPix pixels, not the actual child nodes, and does not contain
    duplicate pixels if a pixel appears in multiple trees.

    Args:
        trees (List[PixelTree]): The list of trees to search for children from
        pixel (HealpixPixel | tuple[int,int]): The pixel to search for children at in all trees

    Returns:
        (List[HealpixPixel]) The list of all HEALPix pixels which have children of the given pixel
        in any of the trees.
    """
    pixel = get_healpix_tuple(pixel)
    pixels_to_add = set()
    for tree in trees:
        if pixel in tree:
            for child_pixel in tree.get_child_pixels(pixel):
                pixels_to_add.add(child_pixel)
    return list(pixels_to_add)


def _should_include_all_pixels_from_tree(tree_type: str, alignment_type: PixelAlignmentType) -> bool:
    """If for a given alignment type, the left or right tree should include all pixels or just the
    ones that overlap with the other tree.

    Args:
        tree_type (str): 'left' for the left tree and 'right' for the right tree
        alignment_type (PixelAlignmentType): The type of alignment being performed

    Returns:
        A boolean indicating if the given tree type should include all pixels
    """
    left_add_types = [PixelAlignmentType.OUTER, PixelAlignmentType.LEFT]
    right_add_types = [PixelAlignmentType.OUTER, PixelAlignmentType.RIGHT]
    return (tree_type == LEFT_TREE_KEY and alignment_type in left_add_types) or (
        tree_type == RIGHT_TREE_KEY and alignment_type in right_add_types
    )


def _generate_pixel_mapping_from_tree(left: PixelTree, right: PixelTree, aligned: PixelTree) -> pd.DataFrame:
    """Generates a pixel mapping dataframe from two trees and their aligned tree

    The pixel mapping dataframe contains columns for the order and pixel of overlapping pixels in
    the left, right and aligned trees. The trees are searched through and this table is generated

    Args:
        left (PixelTree): the left tree used to generate the alignment
        right (PixelTree): the right tree used to generate the alignment
        aligned (PixelTree): the aligned tree as a result of aligning the left and right trees

    Returns:
        (pd.DataFrame) The pixel mapping dataframe where each row contains a pixel from the aligned
        tree and the pixels in the left and right tree that overlap with it
    """
    pixel_mapping_dict = {
        PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: [],
        PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: [],
        PixelAlignment.JOIN_ORDER_COLUMN_NAME: [],
        PixelAlignment.JOIN_PIXEL_COLUMN_NAME: [],
        PixelAlignment.ALIGNED_ORDER_COLUMN_NAME: [],
        PixelAlignment.ALIGNED_PIXEL_COLUMN_NAME: [],
    }
    for leaf_order, leaf_pixel in aligned.get_leaf_descendent_pixels((-1, -1)):
        left_leaf_pixels = left.get_leaf_pixels_at_healpix_pixel((leaf_order, leaf_pixel))
        right_leaf_pixels = right.get_leaf_pixels_at_healpix_pixel((leaf_order, leaf_pixel))
        if len(left_leaf_pixels) == 0:
            left_leaf_pixels = [(None, None)]
        if len(right_leaf_pixels) == 0:
            right_leaf_pixels = [(None, None)]
        for left_order, left_pixel in left_leaf_pixels:
            for right_order, right_pixel in right_leaf_pixels:
                pixel_mapping_dict[PixelAlignment.ALIGNED_ORDER_COLUMN_NAME].append(leaf_order)
                pixel_mapping_dict[PixelAlignment.ALIGNED_PIXEL_COLUMN_NAME].append(leaf_pixel)
                pixel_mapping_dict[PixelAlignment.PRIMARY_ORDER_COLUMN_NAME].append(left_order)
                pixel_mapping_dict[PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME].append(left_pixel)
                pixel_mapping_dict[PixelAlignment.JOIN_ORDER_COLUMN_NAME].append(right_order)
                pixel_mapping_dict[PixelAlignment.JOIN_PIXEL_COLUMN_NAME].append(right_pixel)
    pixel_mapping = pd.DataFrame.from_dict(pixel_mapping_dict).astype(pd.Int64Dtype())
    return pixel_mapping
