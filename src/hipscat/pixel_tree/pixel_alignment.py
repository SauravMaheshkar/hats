from typing import List, Tuple

import numba
import numpy as np
import pandas as pd
from numba import njit

from hipscat.pixel_math.healpix_pixel_function import get_pixels_from_intervals
from hipscat.pixel_tree.pixel_alignment_types import PixelAlignmentType
from hipscat.pixel_tree.pixel_tree import PixelTree


NONE_PIX = np.array([-1, -1])
LEFT_SIDE = 0
RIGHT_SIDE = 1


# pylint: disable=R0903
class PixelAlignment:
    """Represents how two pixel trees align with each other, meaning which pixels match
    or overlap between the catalogs, and a new tree with the smallest pixels from each tree

    For more information on the pixel alignment algorithm, view this document:
    https://docs.google.com/document/d/1YFAQsGCgeEyEZ1IRIam9BbWdN5h2onV6ndO3VM-qjn0/edit?usp=sharing

    Attributes:
        pixel_mapping: A dataframe where each row contains a pixel from each tree that match, and
            which pixel in the aligned tree they match with
        pixel_tree: The aligned tree generated by using the smallest pixels in each tree. For
            example, a tree with pixels at order 0, pixel 1, and a tree with order 1, pixel 4,5,6,
            and 7, would result in the smaller order 1 pixels in the aligned tree.
        alignment_type: The type of alignment describing how to handle nodes which exist in one tree
            but not the other. Options are:

                - inner - only use pixels that appear in both catalogs
                - left - use all pixels that appear in the left catalog and any overlapping from the right
                - right - use all pixels that appear in the right catalog and any overlapping from the left
                - outer - use all pixels from both catalogs
    """

    PRIMARY_ORDER_COLUMN_NAME = "primary_Norder"
    PRIMARY_PIXEL_COLUMN_NAME = "primary_Npix"
    JOIN_ORDER_COLUMN_NAME = "join_Norder"
    JOIN_PIXEL_COLUMN_NAME = "join_Npix"
    ALIGNED_ORDER_COLUMN_NAME = "aligned_Norder"
    ALIGNED_PIXEL_COLUMN_NAME = "aligned_Npix"

    def __init__(
        self,
        aligned_tree: PixelTree,
        pixel_mapping: pd.DataFrame,
        alignment_type: PixelAlignmentType,
    ) -> None:
        self.pixel_tree = aligned_tree
        self.pixel_mapping = pixel_mapping
        self.alignment_type = alignment_type


def align_trees(
    left: PixelTree,
    right: PixelTree,
    alignment_type: PixelAlignmentType = PixelAlignmentType.INNER
) -> PixelAlignment:
    """Generate a `PixelAlignment` object from two pixel trees

    A `PixelAlignment` represents how two pixel trees align with each other, meaning which pixels
    match or overlap between the catalogs, and includes a new tree with the smallest pixels from
    each tree

    For more information on the pixel alignment algorithm, view this document:
    https://docs.google.com/document/d/1YFAQsGCgeEyEZ1IRIam9BbWdN5h2onV6ndO3VM-qjn0/edit?usp=sharing

    Args:
        left: The left tree to align
        right: The right tree to align
        alignment_type: The type of alignment describing how to handle nodes which exist in one tree
            but not the other. Options are:

                - inner - only use pixels that appear in both catalogs
                - left - use all pixels that appear in the left catalog and any overlapping from the right
                - right - use all pixels that appear in the right catalog and any overlapping from the left
                - outer - use all pixels from both catalogs

    Returns:
        The `PixelAlignment` object with the alignment from the two trees
    """
    max_n = max(left.tree_order, right.tree_order)
    left_aligned = left.tree << (2 * (max_n - left.tree_order))
    right_aligned = right.tree << (2 * (max_n - right.tree_order))
    if alignment_type == PixelAlignmentType.INNER:
        result_tree, mapping = align_inner_trees(left_aligned, right_aligned)
        result_tree = np.array(result_tree) if len(result_tree) > 0 else np.empty((0, 2), dtype=np.int64)
        mapping = np.array(mapping).T
    else:
        raise NotImplementedError()
    result_mapping = get_pixel_mapping_df(mapping, max_n)
    return PixelAlignment(PixelTree(result_tree, max_n), result_mapping, alignment_type)


def get_pixel_mapping_df(mapping: np.ndarray, map_order: int) -> pd.DataFrame:
    if len(mapping) > 0:
        l_orders, l_pixels = get_pixels_from_intervals(mapping[0:2], map_order)
        r_orders, r_pixels = get_pixels_from_intervals(mapping[2:4], map_order)
        a_orders, a_pixels = get_pixels_from_intervals(mapping[4:6], map_order)
    else:
        l_orders, l_pixels, r_orders, r_pixels, a_orders, a_pixels = [], [], [], [], [], []
    result_mapping = pd.DataFrame.from_dict({
        PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: l_orders,
        PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: l_pixels,
        PixelAlignment.JOIN_ORDER_COLUMN_NAME: r_orders,
        PixelAlignment.JOIN_PIXEL_COLUMN_NAME: r_pixels,
        PixelAlignment.ALIGNED_ORDER_COLUMN_NAME: a_orders,
        PixelAlignment.ALIGNED_PIXEL_COLUMN_NAME: a_pixels,
    })
    return result_mapping


@njit(numba.types.Tuple((numba.types.List(numba.int64[:]), numba.types.List(numba.int64[::1])))(numba.int64[:, :], numba.int64[:, :]))
def align_inner_trees(
    left: np.ndarray,
    right: np.ndarray,
) -> Tuple[List[np.ndarray], List[np.ndarray]]:
    output = []
    mapping = []
    left_index = 0
    right_index = 0
    while left_index < len(left) and right_index < len(right):
        left_pix = left[left_index]
        right_pix = right[right_index]
        if left_pix[0] >= right_pix[1]:
            # left pix ahead of right, no overlap
            right_index += 1
            continue
        if right_pix[0] >= left_pix[1]:
            # right pix ahead of left, no overlap
            left_index += 1
            continue
        left_size = left_pix[1] - left_pix[0]
        right_size = right_pix[1] - right_pix[0]
        if left_size == right_size:
            # overlapping + same size => same pixel so add and move both on
            output.append(left_pix)
            mapping.append(np.concatenate((left_pix, right_pix, left_pix)))
            left_index += 1
            right_index += 1
            continue
        if left_size < right_size:
            # overlapping and left smaller so add left and move left on
            output.append(left_pix)
            mapping.append(np.concatenate((left_pix, right_pix, left_pix)))
            left_index += 1
            continue
        output.append(right_pix)
        mapping.append(np.concatenate((left_pix, right_pix, right_pix)))
        right_index += 1
    return output, mapping


def align_outer_trees(
    left: np.ndarray,
    right: np.ndarray,
    include_all_left: bool,
    include_all_right: bool,
) -> Tuple[List[np.ndarray], List[np.ndarray]]:
    added_until = 0
    output = []
    mapping = []
    left_index = 0
    right_index = 0
    while left_index < len(left) and right_index < len(right):
        left_pix = left[left_index]
        right_pix = right[right_index]
        if left_pix[0] >= right_pix[1]:
            # left pix ahead of right, no overlap
            if include_all_right:
                if added_until <= right_pix[0]:
                    output.append(right_pix)
                    mapping.append(np.concatenate((NONE_PIX, right_pix, right_pix)))
                    added_until = right_pix[1]
                elif added_until < right_pix[1]:
                    add_pixels_until(added_until, right_pix[1], right_pix, RIGHT_SIDE, output, mapping)
                    added_until = right_pix[1]
            right_index += 1
            continue
        if right_pix[0] >= left_pix[1]:
            # right pix ahead of left, no overlap
            if include_all_left:
                if added_until <= left_pix[0]:
                    output.append(left_pix)
                    mapping.append(np.concatenate((left_pix, NONE_PIX, right_pix)))
                    added_until = left_pix[1]
                elif added_until < left_pix[1]:
                    add_pixels_until(added_until, left_pix[1], left_pix, LEFT_SIDE, output, mapping)
                    added_until = left_pix[1]
            left_index += 1
            continue
        left_size = left_pix[1] - left_pix[0]
        right_size = right_pix[1] - right_pix[0]
        if left_size == right_size:
            # overlapping & same size => same pixel so add and move both on
            output.append(left_pix)
            mapping.append(np.concatenate((left_pix, right_pix, left_pix)))
            added_until = left_pix[1]
            left_index += 1
            right_index += 1
            continue
        if left_size < right_size:
            # overlapping and left smaller so add left and move left on
            if include_all_right and left_pix[0] > right_pix[0] and left_pix[0] > added_until:
                add_from = np.max([added_until, right_pix[0]])
                add_pixels_until(add_from, left_pix[0], right_pix, RIGHT_SIDE, output, mapping)
            output.append(left_pix)
            mapping.append(np.concatenate((left_pix, right_pix, left_pix)))
            added_until = left_pix[1]
            left_index += 1
            continue
        # else overlapping and right smaller so add right and move right on

        if include_all_left and right_pix[0] > left_pix[0] and right_pix[0] > added_until:
            add_from = np.max([added_until, left_pix[0]])
            add_pixels_until(add_from, right_pix[0], left_pix, LEFT_SIDE, output, mapping)
        output.append(right_pix)
        mapping.append(np.concatenate((left_pix, right_pix, right_pix)))
        added_until = right_pix[1]
        right_index += 1
    return output, mapping


def add_pixels_until(add_from, add_to, matching_pix, pix_side, output, mapping):
    pass
