from typing import List, Tuple

import numba
import numpy as np
import pandas as pd
from numba import njit

from hipscat.pixel_tree.pixel_alignment_types import PixelAlignmentType
from hipscat.pixel_tree.pixel_tree import PixelTree

LEFT_TREE_KEY = "left"
RIGHT_TREE_KEY = "right"


# pylint: disable=R0903
class PixelAlignment:
    """Represents how two pixel trees align with each other, meaning which pixels match
    or overlap between the catalogs, and a new tree with the smallest pixels from each tree

    For more information on the pixel alignment algorithm, view this document:
    https://docs.google.com/document/d/1YFAQsGCgeEyEZ1IRIam9BbWdN5h2onV6ndO3VM-qjn0/edit?usp=sharing

    Attributes:
        pixel_mapping: A dataframe where each row contains a pixel from each tree that match, and
            which pixel in the aligned tree they match with
        pixel_tree: The aligned tree generated by using the smallest pixels in each tree. For
            example, a tree with pixels at order 0, pixel 1, and a tree with order 1, pixel 4,5,6,
            and 7, would result in the smaller order 1 pixels in the aligned tree.
        alignment_type: The type of alignment describing how to handle nodes which exist in one tree
            but not the other. Options are:

                - inner - only use pixels that appear in both catalogs
                - left - use all pixels that appear in the left catalog and any overlapping from the right
                - right - use all pixels that appear in the right catalog and any overlapping from the left
                - outer - use all pixels from both catalogs
    """

    PRIMARY_ORDER_COLUMN_NAME = "primary_Norder"
    PRIMARY_PIXEL_COLUMN_NAME = "primary_Npix"
    JOIN_ORDER_COLUMN_NAME = "join_Norder"
    JOIN_PIXEL_COLUMN_NAME = "join_Npix"
    ALIGNED_ORDER_COLUMN_NAME = "aligned_Norder"
    ALIGNED_PIXEL_COLUMN_NAME = "aligned_Npix"

    def __init__(
        self,
        aligned_tree: PixelTree,
        pixel_mapping: pd.DataFrame,
        alignment_type: PixelAlignmentType,
    ) -> None:
        self.pixel_tree = aligned_tree
        self.pixel_mapping = pixel_mapping
        self.alignment_type = alignment_type


def align_trees(
    left: PixelTree,
    right: PixelTree,
    alignment_type: PixelAlignmentType = PixelAlignmentType.INNER
) -> PixelAlignment:
    """Generate a `PixelAlignment` object from two pixel trees

    A `PixelAlignment` represents how two pixel trees align with each other, meaning which pixels
    match or overlap between the catalogs, and includes a new tree with the smallest pixels from
    each tree

    For more information on the pixel alignment algorithm, view this document:
    https://docs.google.com/document/d/1YFAQsGCgeEyEZ1IRIam9BbWdN5h2onV6ndO3VM-qjn0/edit?usp=sharing

    Args:
        left: The left tree to align
        right: The right tree to align
        alignment_type: The type of alignment describing how to handle nodes which exist in one tree
            but not the other. Options are:

                - inner - only use pixels that appear in both catalogs
                - left - use all pixels that appear in the left catalog and any overlapping from the right
                - right - use all pixels that appear in the right catalog and any overlapping from the left
                - outer - use all pixels from both catalogs

    Returns:
        The `PixelAlignment` object with the alignment from the two trees
    """
    max_n = max(left.order, right.order)
    left_aligned = left.pixels << (2 * (max_n - left.order))
    right_aligned = right.pixels << (2 * (max_n - right.order))
    if alignment_type == PixelAlignmentType.INNER:
        result_tree, mapping = align_inner_trees(left_aligned, right_aligned)
        result_tree = np.array(result_tree)
        mapping = np.array(mapping).T
    else:
        raise NotImplementedError()
    result_mapping = get_pixel_mapping_df(mapping, max_n)
    return PixelAlignment(PixelTree(result_tree, max_n), result_mapping, alignment_type)


def get_pixel_mapping_df(mapping: np.ndarray, map_order: int) -> pd.DataFrame:
    l_orders = map_order - ((np.vectorize(lambda x: int(x).bit_length())(mapping[1] - mapping[0]) - 1) >> 1)
    l_pixels = mapping[0] >> (map_order - l_orders)
    r_orders = map_order - ((np.vectorize(lambda x: int(x).bit_length())(mapping[3] - mapping[2]) - 1) >> 1)
    r_pixels = mapping[2] >> (map_order - r_orders)
    a_orders = map_order - ((np.vectorize(lambda x: int(x).bit_length())(mapping[5] - mapping[4]) - 1) >> 1)
    a_pixels = mapping[4] >> (map_order - a_orders)
    result_mapping = pd.DataFrame.from_dict({
        PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: l_orders,
        PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: l_pixels,
        PixelAlignment.JOIN_ORDER_COLUMN_NAME: r_orders,
        PixelAlignment.JOIN_PIXEL_COLUMN_NAME: r_pixels,
        PixelAlignment.ALIGNED_ORDER_COLUMN_NAME: a_orders,
        PixelAlignment.ALIGNED_PIXEL_COLUMN_NAME: a_pixels,
    })
    return result_mapping


@njit(numba.types.Tuple((numba.types.List(numba.int64[:]), numba.types.List(numba.int64[::1])))(numba.int64[:, :], numba.int64[:, :]))
def align_inner_trees(
    left: np.ndarray,
    right: np.ndarray,
) -> Tuple[List[np.ndarray], List[np.ndarray]]:

    output = []
    mapping = []
    left_index = 0
    right_index = 0
    while left_index < len(left) and right_index < len(right):
        left_pix = left[left_index]
        right_pix = right[right_index]
        if left_pix[0] >= right_pix[1]:
            # left pix ahead of right, no overlap
            right_index += 1
            continue
        if right_pix[0] >= left_pix[1]:
            # right pix ahead of left, no overlap
            left_index += 1
            continue
        left_size = left_pix[1] - left_pix[0]
        right_size = right_pix[1] - right_pix[0]
        if left_size == right_size:
            # overlapping + same size => same pixel so add and move both on
            output.append(left_pix)
            mapping.append(np.concatenate((left_pix, right_pix, left_pix)))
            left_index += 1
            right_index += 1
            continue
        if left_size < right_size:
            # overlapping and left smaller so add left and move left on
            output.append(left_pix)
            mapping.append(np.concatenate((left_pix, right_pix, left_pix)))
            left_index += 1
            continue
        output.append(right_pix)
        mapping.append(np.concatenate((left_pix, right_pix, right_pix)))
        right_index += 1
    return output, mapping
