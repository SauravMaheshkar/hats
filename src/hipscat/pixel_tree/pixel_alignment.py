from typing import List

import pandas as pd

from hipscat.pixel_math import HealpixInputTypes, HealpixPixel, get_healpix_pixel
from hipscat.pixel_tree.pixel_alignment_types import PixelAlignmentType
from hipscat.pixel_tree.pixel_node_type import PixelNodeType
from hipscat.pixel_tree.pixel_tree import PixelTree
from hipscat.pixel_tree.pixel_tree_builder import PixelTreeBuilder


# pylint: disable=R0903
class PixelAlignment:
    """Represents how two pixel trees align with each other, meaning which pixels match
    or overlap between the catalogs, and a new tree with the smallest pixels from each tree

    Attributes:
        pixel_mapping: A dataframe where each row contains a pixel from each tree that match, and
            which pixel in the aligned tree they match with
        pixel_tree: The aligned tree generated by using the smallest pixels in each tree. For
            example, a tree with pixels at order 0, pixel 1, and a tree with order 1, pixel 4,5,6,
            and 7, would result in the smaller order 1 pixels in the aligned tree.
        alignment_type: The type of alignment describing how to handle nodes which exist in one tree
            but not the other. Options are:
            inner - only use pixels that appear in both catalogs
            left - use all pixels that appear in the left catalog and any overlapping from the right
            right - use all pixels that appear in the right catalog and any overlapping from the
                left
            outer - use all pixels from both catalogs
    """

    PRIMARY_ORDER_COLUMN_NAME = "primary_Norder"
    PRIMARY_PIXEL_COLUMN_NAME = "primary_Npix"
    JOIN_ORDER_COLUMN_NAME = "join_Norder"
    JOIN_PIXEL_COLUMN_NAME = "join_Npix"
    ALIGNED_ORDER_COLUMN_NAME = "aligned_Norder"
    ALIGNED_PIXEL_COLUMN_NAME = "aligned_Npix"

    def __init__(
        self,
        aligned_tree: PixelTree,
        pixel_mapping: pd.DataFrame,
        alignment_type: PixelAlignmentType,
    ) -> None:
        self.pixel_tree = aligned_tree
        self.pixel_mapping = pixel_mapping
        self.alignment_type = alignment_type


# pylint: disable=R0912
def align_trees(
    left: PixelTree,
    right: PixelTree,
    alignment_type: PixelAlignmentType = PixelAlignmentType.INNER,
) -> PixelAlignment:
    """Generate a `PixelAlignment` object from two pixel trees

    A `PixelAlignment` represents how two pixel trees align with each other, meaning which pixels
    match or overlap between the catalogs, and includes a new tree with the smallest pixels from
    each tree

    Args:
        left: The left tree to align
        right: The right tree to align
        alignment_type: The type of alignment describing how to handle nodes which exist in one tree
            but not the other. Options are:
            inner - only use pixels that appear in both catalogs
            left - use all pixels that appear in the left catalog and any overlapping from the right
            right - use all pixels that appear in the right catalog and any overlapping from the
                left
            outer - use all pixels from both catalogs
    Returns:
        The `PixelAlignment` object with the alignment from the two trees
    """

    tree_builder = PixelTreeBuilder()
    pixels_to_search = _get_children_pixels_from_trees(
        [left, right], left.root_pixel.pixel
    )

    while len(pixels_to_search) > 0:
        search_pixel = pixels_to_search.pop(0)
        if search_pixel in left and search_pixel in right:
            left_node = left[search_pixel]
            right_node = right[search_pixel]
            if left_node.node_type == right_node.node_type:
                if left_node.node_type == PixelNodeType.LEAF:
                    tree_builder.create_node_and_parent_if_not_exist(
                        search_pixel, PixelNodeType.LEAF
                    )
                else:
                    pixels_to_search += _get_children_pixels_from_trees(
                        [left, right], search_pixel
                    )
            else:
                if left_node.node_type == PixelNodeType.LEAF:
                    tree_with_leaf_node = "left"
                    inner_node = right_node
                else:
                    tree_with_leaf_node = "right"
                    inner_node = left_node
                if _should_include_all_pixels_from_tree(
                    tree_with_leaf_node, alignment_type
                ):
                    tree_builder.create_node_and_parent_if_not_exist(
                        search_pixel, PixelNodeType.LEAF
                    )
                    tree_builder.split_leaf_to_match_partitioning(inner_node)
                else:
                    tree_builder.create_node_and_parent_if_not_exist(
                        search_pixel, PixelNodeType.INNER
                    )
                    tree_builder.add_all_descendants_from_node(inner_node)
        elif search_pixel in left and search_pixel not in right:
            if _should_include_all_pixels_from_tree("left", alignment_type):
                tree_builder.create_node_and_parent_if_not_exist(
                    search_pixel, left[search_pixel].node_type
                )
                tree_builder.add_all_descendants_from_node(left[search_pixel])
        elif search_pixel in right and search_pixel not in left:
            if _should_include_all_pixels_from_tree("right", alignment_type):
                tree_builder.create_node_and_parent_if_not_exist(
                    search_pixel, right[search_pixel].node_type
                )
                tree_builder.add_all_descendants_from_node(right[search_pixel])
    tree = tree_builder.build()
    pixel_mapping = _generate_pixel_mapping_from_tree(left, right, tree)
    return PixelAlignment(tree, pixel_mapping, alignment_type)


def _get_children_pixels_from_trees(
    trees: List[PixelTree], pixel: HealpixInputTypes
) -> List[HealpixPixel]:
    pixel = get_healpix_pixel(pixel)
    pixels_to_add = set()
    for tree in trees:
        if pixel in tree:
            for node in tree[pixel].children:
                pixels_to_add.add(node.pixel)
    return list(pixels_to_add)


def _should_include_all_pixels_from_tree(
    tree_type: str, alignment_type: PixelAlignmentType
) -> bool:
    left_add_types = [PixelAlignmentType.OUTER, PixelAlignmentType.LEFT]
    right_add_types = [PixelAlignmentType.OUTER, PixelAlignmentType.RIGHT]
    return (tree_type == "left" and alignment_type in left_add_types) or \
        (tree_type == "right" and alignment_type in right_add_types)


def _generate_pixel_mapping_from_tree(left, right, tree):
    pixel_mapping_dict = {
        PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: [],
        PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: [],
        PixelAlignment.JOIN_ORDER_COLUMN_NAME: [],
        PixelAlignment.JOIN_PIXEL_COLUMN_NAME: [],
        PixelAlignment.ALIGNED_ORDER_COLUMN_NAME: [],
        PixelAlignment.ALIGNED_PIXEL_COLUMN_NAME: [],
    }
    for leaf_node in tree.root_pixel.get_all_leaf_descendants():
        left_leaf_nodes = left.get_leaf_nodes_at_healpix_pixel(leaf_node.pixel)
        right_leaf_nodes = right.get_leaf_nodes_at_healpix_pixel(leaf_node.pixel)
        if len(left_leaf_nodes) == 0:
            left_leaf_nodes = [None]
        if len(right_leaf_nodes) == 0:
            right_leaf_nodes = [None]
        for left_node in left_leaf_nodes:
            for right_node in right_leaf_nodes:
                pixel_mapping_dict[PixelAlignment.ALIGNED_ORDER_COLUMN_NAME].append(
                    leaf_node.hp_order
                )
                pixel_mapping_dict[PixelAlignment.ALIGNED_PIXEL_COLUMN_NAME].append(
                    leaf_node.hp_pixel
                )
                left_order = left_node.hp_order if left_node is not None else None
                left_pixel = left_node.hp_pixel if left_node is not None else None
                pixel_mapping_dict[PixelAlignment.PRIMARY_ORDER_COLUMN_NAME].append(
                    left_order
                )
                pixel_mapping_dict[PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME].append(
                    left_pixel
                )
                right_order = right_node.hp_order if right_node is not None else None
                right_pixel = right_node.hp_pixel if right_node is not None else None
                pixel_mapping_dict[PixelAlignment.JOIN_ORDER_COLUMN_NAME].append(
                    right_order
                )
                pixel_mapping_dict[PixelAlignment.JOIN_PIXEL_COLUMN_NAME].append(
                    right_pixel
                )
    pixel_mapping = pd.DataFrame.from_dict(pixel_mapping_dict)
    return pixel_mapping
